{
  "name": "GaaP MCP Tool: Audit Log Event",
  "nodes": [
    {
      "parameters": {},
      "id": "workflow-trigger",
      "name": "Execute Workflow Trigger",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1,
      "position": [0, 0]
    },
    {
      "parameters": {
        "jsCode": "// =============================================================================\n// gaap_audit_log_event - Log compliance event with optional CamDL anchoring\n// =============================================================================\n// GaaP Layer: L4 (Compliance & Audit)\n//\n// SINGLE EVENT MODE:\n//   event_type: string (required) - e.g., 'order.created', 'payment.captured'\n//   entity_type: string (required) - e.g., 'order', 'payment', 'customer'\n//   entity_id: string (required) - e.g., 'ORD-2025-001'\n//   state_change: object (optional) - { previous: {...}, new: {...} }\n//   previous_hash: string (optional) - Hash of previous event in chain\n//   metadata: object (optional) - Additional context\n//   anchor_to_camdl: boolean (optional) - Request immediate CamDL anchoring\n//\n// BATCH MODE:\n//   batch_mode: true (required for batch)\n//   events: array (required) - Array of event objects with same structure\n//   anchor_to_camdl: boolean (optional) - Apply to all events\n//\n// Output:\n//   audit_event_id: UUID (or array in batch mode)\n//   correlation_id: string\n//   event_hash: string (SHA-256)\n//   camdl_anchored: boolean\n// =============================================================================\n\nconst crypto = require('crypto');\n\nconst input = $input.first().json;\nconst startTime = input._startTime || Date.now();\nconst requestId = input.request_id;\nconst tenantId = input.tenant_context?.tenant_id;\nconst correlationId = input.tenant_context?.correlation_id || `CRR-${Date.now()}-${crypto.randomBytes(4).toString('hex')}`;\n\nconst params = input.params || {};\n\n// Helper function to prepare a single event\nfunction prepareEvent(eventParams, index = null) {\n  const previousState = eventParams.state_change?.previous || null;\n  const newState = eventParams.state_change?.new || null;\n  const stateChangeSummary = eventParams.state_change \n    ? `${eventParams.event_type}: ${JSON.stringify(Object.keys(eventParams.state_change.new || {}))}`\n    : null;\n\n  const eventTimestamp = new Date().toISOString();\n  const canonicalData = [\n    tenantId,\n    eventParams.event_type,\n    eventParams.entity_type,\n    eventParams.entity_id,\n    JSON.stringify(newState || {}),\n    eventParams.previous_hash || '',\n    eventTimestamp\n  ].join('|');\n\n  const eventHash = crypto.createHash('sha256').update(canonicalData).digest('hex');\n  const auditEventId = crypto.randomUUID();\n\n  return {\n    _startTime: startTime,\n    request_id: requestId,\n    tenant_id: tenantId,\n    correlation_id: correlationId,\n    audit_event_id: auditEventId,\n    event_type: eventParams.event_type,\n    entity_type: eventParams.entity_type,\n    entity_id: eventParams.entity_id,\n    previous_state: previousState,\n    new_state: newState,\n    state_change_summary: stateChangeSummary,\n    event_hash: eventHash,\n    previous_hash: eventParams.previous_hash || null,\n    metadata: eventParams.metadata || {},\n    event_timestamp: eventTimestamp,\n    anchor_to_camdl: eventParams.anchor_to_camdl ?? params.anchor_to_camdl ?? false,\n    source_tool: 'gaap_audit_log_event',\n    source_workflow: input.meta?.source_workflow || null,\n    source_ip: input.source_ip || null,\n    _batch_mode: params.batch_mode || false,\n    _batch_index: index\n  };\n}\n\n// Check for batch mode\nif (params.batch_mode === true) {\n  // Validate batch mode params\n  if (!params.events || !Array.isArray(params.events) || params.events.length === 0) {\n    return [{\n      json: {\n        _error: true,\n        error: {\n          code: 'L4_AUDIT_BATCH_MISSING_EVENTS',\n          message: 'Batch mode requires non-empty events array',\n          recoverable: false\n        },\n        meta: {\n          request_id: requestId,\n          execution_ms: Date.now() - startTime,\n          gaap_layer: 'L4',\n          camdl_anchored: false\n        }\n      }\n    }];\n  }\n\n  // Validate each event in the batch\n  const requiredParams = ['event_type', 'entity_type', 'entity_id'];\n  for (let i = 0; i < params.events.length; i++) {\n    const event = params.events[i];\n    const missingParams = requiredParams.filter(p => !event[p]);\n    if (missingParams.length > 0) {\n      return [{\n        json: {\n          _error: true,\n          error: {\n            code: 'L4_AUDIT_BATCH_INVALID_EVENT',\n            message: `Event at index ${i} missing required parameters: ${missingParams.join(', ')}`,\n            recoverable: false\n          },\n          meta: {\n            request_id: requestId,\n            execution_ms: Date.now() - startTime,\n            gaap_layer: 'L4',\n            camdl_anchored: false\n          }\n        }\n      }];\n    }\n  }\n\n  // Process all events - return multiple items for downstream processing\n  return params.events.map((event, index) => ({\n    json: prepareEvent(event, index)\n  }));\n}\n\n// Single event mode - validate required params\nconst requiredParams = ['event_type', 'entity_type', 'entity_id'];\nconst missingParams = requiredParams.filter(p => !params[p]);\n\nif (missingParams.length > 0) {\n  return [{\n    json: {\n      _error: true,\n      error: {\n        code: 'L4_AUDIT_MISSING_PARAMS',\n        message: `Missing required parameters: ${missingParams.join(', ')}`,\n        recoverable: false\n      },\n      meta: {\n        request_id: requestId,\n        execution_ms: Date.now() - startTime,\n        gaap_layer: 'L4',\n        camdl_anchored: false\n      }\n    }\n  }];\n}\n\n// Prepare single event\nreturn [{\n  json: prepareEvent(params)\n}];"
      },
      "id": "prepare-event",
      "name": "Prepare Event",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [220, 0]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "check-error",
              "leftValue": "={{ $json._error }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-validation",
      "name": "Check Validation",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [440, 0]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Set tenant context for RLS\nSET app.current_tenant_id = '{{ $json.tenant_id }}';\n\n-- Insert audit event\nINSERT INTO gaap_mcp.audit_events (\n  audit_event_id,\n  tenant_id,\n  correlation_id,\n  event_type,\n  entity_type,\n  entity_id,\n  previous_state,\n  new_state,\n  state_change_summary,\n  event_hash,\n  previous_hash,\n  metadata,\n  event_timestamp,\n  source_tool,\n  source_workflow,\n  source_ip\n) VALUES (\n  '{{ $json.audit_event_id }}'::UUID,\n  '{{ $json.tenant_id }}'::UUID,\n  '{{ $json.correlation_id }}',\n  '{{ $json.event_type }}',\n  '{{ $json.entity_type }}',\n  '{{ $json.entity_id }}',\n  {{ $json.previous_state ? \"'\" + JSON.stringify($json.previous_state).replace(/'/g, \"''\") + \"'::JSONB\" : 'NULL' }},\n  {{ $json.new_state ? \"'\" + JSON.stringify($json.new_state).replace(/'/g, \"''\") + \"'::JSONB\" : 'NULL' }},\n  {{ $json.state_change_summary ? \"'\" + $json.state_change_summary.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  '{{ $json.event_hash }}',\n  {{ $json.previous_hash ? \"'\" + $json.previous_hash + \"'\" : 'NULL' }},\n  '{{ JSON.stringify($json.metadata).replace(/'/g, \"''\") }}'::JSONB,\n  '{{ $json.event_timestamp }}'::TIMESTAMPTZ,\n  '{{ $json.source_tool }}',\n  {{ $json.source_workflow ? \"'\" + $json.source_workflow + \"'\" : 'NULL' }},\n  {{ $json.source_ip ? \"'\" + $json.source_ip + \"'::INET\" : 'NULL' }}\n)\nRETURNING audit_event_id, event_hash, recorded_at;",
        "options": {}
      },
      "id": "insert-event",
      "name": "Insert Event",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [660, -100],
      "credentials": {
        "postgres": {
          "id": "aUYl5Qo5xhAItjGP",
          "name": "CamFinTech PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "check-anchor",
              "leftValue": "={{ $('Prepare Event').first().json.anchor_to_camdl }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-anchor-request",
      "name": "Check Anchor Request",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [880, -100]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://lg99tn8y8g.execute-api.ap-southeast-1.amazonaws.com/v1/camdl/audit/log",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "X-Correlation-ID",
              "value": "={{ $('Prepare Event').first().json.correlation_id }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"event_type\": \"{{ $('Prepare Event').first().json.event_type }}\",\n  \"entity_type\": \"{{ $('Prepare Event').first().json.entity_type }}\",\n  \"entity_id\": \"{{ $('Prepare Event').first().json.entity_id }}\",\n  \"event_hash\": \"{{ $('Insert Event').first().json.event_hash }}\",\n  \"event_timestamp\": \"{{ $('Prepare Event').first().json.event_timestamp }}\"\n}",
        "options": {
          "timeout": 10000
        }
      },
      "id": "call-aws-camdl",
      "name": "Call AWS CamDL",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1100, -300],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// =============================================================================\n// Map AWS CamDL Response\n// =============================================================================\nconst prepareData = $('Prepare Event').first().json;\nconst insertResult = $('Insert Event').first().json;\nconst awsResponse = $input.first().json;\n\nreturn [{\n  json: {\n    camdl_anchored: true,\n    camdl_anchor_id: awsResponse.anchor_id || awsResponse.camdl_anchor_id,\n    camdl_block_number: awsResponse.block_number || awsResponse.camdl_block_number,\n    camdl_tx_hash: awsResponse.tx_hash || awsResponse.camdl_tx_hash,\n    audit_event_id: insertResult.audit_event_id,\n    event_hash: insertResult.event_hash,\n    correlation_id: prepareData.correlation_id,\n    _startTime: prepareData._startTime,\n    request_id: prepareData.request_id,\n    _aws_endpoint: true\n  }\n}];"
      },
      "id": "map-aws-camdl-response",
      "name": "Map AWS CamDL Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1320, -350]
    },
    {
      "parameters": {
        "jsCode": "// =============================================================================\n// CamDL Anchoring (Local Fallback)\n// =============================================================================\n// Used when AWS endpoint fails or is disabled.\n// Generates a mock CamDL response for development/testing.\n// =============================================================================\n\nconst prepareData = $('Prepare Event').first().json;\nconst insertResult = $('Insert Event').first().json;\n\n// Fallback: Generate mock CamDL response\nconst mockAnchorId = `CAMDL-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`;\nconst mockBlockNumber = Math.floor(Date.now() / 1000);\nconst mockTxHash = `0x${require('crypto').randomBytes(32).toString('hex')}`;\n\nreturn [{\n  json: {\n    camdl_anchored: true,\n    camdl_anchor_id: mockAnchorId,\n    camdl_block_number: mockBlockNumber,\n    camdl_tx_hash: mockTxHash,\n    audit_event_id: insertResult.audit_event_id,\n    event_hash: insertResult.event_hash,\n    correlation_id: prepareData.correlation_id,\n    _startTime: prepareData._startTime,\n    request_id: prepareData.request_id,\n    _fallback: true\n  }\n}];"
      },
      "id": "anchor-to-camdl-fallback",
      "name": "Anchor to CamDL (Fallback)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1320, -200]
    },
    {
      "parameters": {
        "mode": "chooseBranch",
        "output": "extra"
      },
      "id": "merge-camdl-result",
      "name": "Merge CamDL Result",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [1540, -280]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Update audit event with CamDL anchor info\nUPDATE gaap_mcp.audit_events\nSET \n  camdl_anchored = TRUE,\n  camdl_anchor_id = '{{ $('Merge CamDL Result').first().json.camdl_anchor_id }}',\n  camdl_block_number = {{ $('Merge CamDL Result').first().json.camdl_block_number }},\n  camdl_tx_hash = '{{ $('Merge CamDL Result').first().json.camdl_tx_hash }}',\n  camdl_anchored_at = NOW()\nWHERE audit_event_id = '{{ $('Merge CamDL Result').first().json.audit_event_id }}'::UUID;",
        "options": {}
      },
      "id": "update-anchor-status",
      "name": "Update Anchor Status",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [1320, -200],
      "credentials": {
        "postgres": {
          "id": "aUYl5Qo5xhAItjGP",
          "name": "CamFinTech PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Build success response (with anchoring)\n// Process ALL input items for batch mode support\nconst allInputs = $input.all();\nconst prepareItems = $('Prepare Event').all();\n\nreturn allInputs.map((item, idx) => {\n  const anchorData = item.json;\n  // Find matching prepare data by audit_event_id\n  const prepareData = prepareItems.find(p => p.json.audit_event_id === anchorData.audit_event_id)?.json || prepareItems[idx]?.json || {};\n  \n  return {\n    json: {\n      data: {\n        audit_event_id: anchorData.audit_event_id,\n        event_hash: anchorData.event_hash,\n        event_type: prepareData.event_type,\n        entity_type: prepareData.entity_type,\n        entity_id: prepareData.entity_id,\n        camdl_anchor_id: anchorData.camdl_anchor_id,\n        camdl_block_number: anchorData.camdl_block_number,\n        camdl_tx_hash: anchorData.camdl_tx_hash\n      },\n      correlation_id: anchorData.correlation_id,\n      audit_event_id: anchorData.audit_event_id,\n      camdl_anchored: true,\n      _batch_mode: prepareData._batch_mode || false,\n      _batch_index: prepareData._batch_index,\n      _startTime: prepareData._startTime,\n      meta: {\n        request_id: anchorData.request_id,\n        execution_ms: Date.now() - (anchorData._startTime || Date.now()),\n        gaap_layer: 'L4',\n        camdl_anchored: true,\n        aws_endpoint: anchorData._aws_endpoint || false,\n        fallback_used: anchorData._fallback || false\n      }\n    }\n  };\n});"
      },
      "id": "build-anchored-response",
      "name": "Build Anchored Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1540, -200]
    },
    {
      "parameters": {
        "jsCode": "// Build success response (without anchoring)\n// Process ALL input items for batch mode support\nconst allInputs = $input.all();\nconst prepareItems = $('Prepare Event').all();\n\nreturn allInputs.map((item, idx) => {\n  const insertData = item.json;\n  // Find matching prepare data by audit_event_id\n  const prepareData = prepareItems.find(p => p.json.audit_event_id === insertData.audit_event_id)?.json || prepareItems[idx]?.json || {};\n  \n  return {\n    json: {\n      data: {\n        audit_event_id: insertData.audit_event_id,\n        event_hash: insertData.event_hash,\n        event_type: prepareData.event_type,\n        entity_type: prepareData.entity_type,\n        entity_id: prepareData.entity_id\n      },\n      correlation_id: prepareData.correlation_id,\n      audit_event_id: insertData.audit_event_id,\n      camdl_anchored: false,\n      _batch_mode: prepareData._batch_mode || false,\n      _batch_index: prepareData._batch_index,\n      _startTime: prepareData._startTime,\n      meta: {\n        request_id: prepareData.request_id,\n        execution_ms: Date.now() - (prepareData._startTime || Date.now()),\n        gaap_layer: 'L4',\n        camdl_anchored: false\n      }\n    }\n  };\n});"
      },
      "id": "build-unanchored-response",
      "name": "Build Unanchored Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1100, 0]
    },
    {
      "parameters": {},
      "id": "merge-responses",
      "name": "Merge Responses",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [1760, -100]
    },
    {
      "parameters": {
        "jsCode": "// =============================================================================\n// Aggregate Results - Handle batch mode aggregation\n// =============================================================================\nconst allItems = $input.all();\n\n// Check if this is an error response (single item with _error)\nif (allItems.length === 1 && allItems[0].json._error) {\n  return allItems;\n}\n\n// Check if batch mode\nconst firstItem = allItems[0].json;\nif (!firstItem._batch_mode) {\n  // Single event mode - return as-is (remove batch flags)\n  const result = { ...firstItem };\n  delete result._batch_mode;\n  delete result._batch_index;\n  return [{ json: result }];\n}\n\n// Batch mode - aggregate all results\nconst events = allItems\n  .map(item => item.json)\n  .sort((a, b) => (a._batch_index || 0) - (b._batch_index || 0))\n  .map(item => ({\n    audit_event_id: item.audit_event_id,\n    event_type: item.data.event_type,\n    entity_type: item.data.entity_type,\n    entity_id: item.data.entity_id,\n    event_hash: item.data.event_hash,\n    camdl_anchored: item.camdl_anchored,\n    camdl_anchor_id: item.data.camdl_anchor_id || null,\n    camdl_tx_hash: item.data.camdl_tx_hash || null\n  }));\n\nconst aggregatedMeta = allItems[0].json.meta;\nconst correlation_id = firstItem.correlation_id;\n\nreturn [{\n  json: {\n    data: {\n      batch_mode: true,\n      events_count: events.length,\n      events: events\n    },\n    correlation_id: correlation_id,\n    meta: {\n      request_id: aggregatedMeta.request_id,\n      execution_ms: Date.now() - (allItems[0].json._startTime || Date.now()),\n      gaap_layer: 'L4',\n      batch_mode: true,\n      events_processed: events.length\n    }\n  }\n}];"
      },
      "id": "aggregate-results",
      "name": "Aggregate Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1980, -100]
    }
  ],
  "connections": {
    "Execute Workflow Trigger": {
      "main": [
        [
          {
            "node": "Prepare Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Event": {
      "main": [
        [
          {
            "node": "Check Validation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Validation": {
      "main": [
        [
          {
            "node": "Merge Responses",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Insert Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Event": {
      "main": [
        [
          {
            "node": "Check Anchor Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Anchor Request": {
      "main": [
        [
          {
            "node": "Call AWS CamDL",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Unanchored Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call AWS CamDL": {
      "main": [
        [
          {
            "node": "Map AWS CamDL Response",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Anchor to CamDL (Fallback)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Map AWS CamDL Response": {
      "main": [
        [
          {
            "node": "Merge CamDL Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Anchor to CamDL (Fallback)": {
      "main": [
        [
          {
            "node": "Merge CamDL Result",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge CamDL Result": {
      "main": [
        [
          {
            "node": "Update Anchor Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Anchor Status": {
      "main": [
        [
          {
            "node": "Build Anchored Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Anchored Response": {
      "main": [
        [
          {
            "node": "Merge Responses",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Unanchored Response": {
      "main": [
        [
          {
            "node": "Merge Responses",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Responses": {
      "main": [
        [
          {
            "node": "Aggregate Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "gaap-mcp"
  },
  "pinData": {},
  "versionId": "1.0.0",
  "triggerCount": 0,
  "tags": [
    {
      "name": "gaap-mcp",
      "createdAt": "2025-01-11T00:00:00.000Z",
      "updatedAt": "2025-01-11T00:00:00.000Z"
    },
    {
      "name": "tool",
      "createdAt": "2025-01-11T00:00:00.000Z",
      "updatedAt": "2025-01-11T00:00:00.000Z"
    },
    {
      "name": "L4-compliance",
      "createdAt": "2025-01-11T00:00:00.000Z",
      "updatedAt": "2025-01-11T00:00:00.000Z"
    }
  ]
}
